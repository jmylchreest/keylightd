name: Flatpak Build

on:
  workflow_call:
    inputs:
      tag_name:
        description: "The tag name for the release"
        required: true
        type: string
      version:
        description: "The version number (without v prefix)"
        required: true
        type: string
      release_type:
        description: "Type of release: release or snapshot"
        required: true
        type: string
      release_id:
        description: "The ID of the release workflow run"
        required: false
        type: string

jobs:
  flatpak:
    name: Build Flatpak for ${{ matrix.arch }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [amd64, arm64]
    container:
      image: ghcr.io/flathub-infra/flatpak-github-actions:gnome-48
      options: --privileged
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create directories
        run: mkdir -p binaries

      - name: Install dependencies
        run: dnf install -y jq curl

      - name: Download release assets
        run: |
          mkdir -p artifacts
          ARCH="${{ matrix.arch }}"
          TAG="${{ inputs.tag_name }}"
          REPO="${{ github.repository }}"

          echo "Downloading release assets for tag: ${TAG}, architecture: ${ARCH}"

          # Download the tarball for this architecture
          RELEASE_JSON=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${REPO}/releases/tags/${TAG}")

          if [ $? -ne 0 ]; then
            echo "ERROR: Failed to fetch release information"
            exit 1
          fi

          # Check if release exists
          RELEASE_ID=$(echo "$RELEASE_JSON" | jq -r '.id')
          if [ "$RELEASE_ID" = "null" ]; then
            echo "ERROR: Release with tag ${TAG} not found"
            exit 1
          fi

          ASSET_URL=$(echo "$RELEASE_JSON" | \
            jq -r '.assets[] | select(.name | contains("linux_'${ARCH}'")) | .browser_download_url')

          if [ -n "$ASSET_URL" ]; then
            echo "Found asset URL: $ASSET_URL"
            FILENAME=$(basename "$ASSET_URL")
            curl -L \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/octet-stream" \
              "$ASSET_URL" --output "artifacts/$FILENAME"
            echo "Downloaded to artifacts/$FILENAME"
          else
            echo "ERROR: No matching release asset found for architecture ${ARCH} in tag ${TAG}"
            echo "Available assets:"
            echo "$RELEASE_JSON" | jq -r '.assets[] | .name'
            exit 1
          fi

      - name: Debug downloaded assets
        run: |
          echo "=== Listing downloaded assets ==="
          find artifacts -type f | sort
          echo "=== Detailed listing of artifacts directory ==="
          find artifacts -type f -exec ls -la {} \;

      - name: Extract binaries from artifacts
        run: |
          ARCH="${{ matrix.arch }}"
          VERSION="${{ inputs.version }}"
          TAG="${{ inputs.tag_name }}"

          echo "=== Searching for tarball for architecture: ${ARCH} ==="

          # Find and extract from tarball
          TARBALL=$(find artifacts -name "*linux_${ARCH}*.tar.gz" | head -n 1)
          if [ -n "$TARBALL" ]; then
            echo "Found tarball: $TARBALL"
            mkdir -p extracted
            tar -xf "$TARBALL" -C extracted

            # Copy binaries to the binaries directory
            if [ -f "extracted/keylightd" ] && [ -f "extracted/keylightctl" ]; then
              cp extracted/keylightd binaries/
              cp extracted/keylightctl binaries/
              echo "Successfully extracted binaries from tarball"
            else
              echo "ERROR: Tarball did not contain expected binaries"
              exit 1
            fi
          else
            echo "ERROR: Could not find tarball for architecture ${ARCH}"
            exit 1
          fi

          # Make binaries executable
          chmod +x binaries/keylightd binaries/keylightctl

          # List the binaries and verify they exist
          echo "=== Final binaries for Flatpak build ==="
          ls -la binaries/
          if [ -f "binaries/keylightd" ] && [ -x "binaries/keylightd" ] && \
             [ -f "binaries/keylightctl" ] && [ -x "binaries/keylightctl" ]; then
            echo "Both binaries exist and are executable"
            file binaries/keylightd
            file binaries/keylightctl
          else
            echo "ERROR: Missing or non-executable binaries"
            exit 1
          fi

      - name: Update Flatpak Manifest
        run: |
          # Ensure the tag is valid for the manifest
          SAFE_TAG="${{ inputs.tag_name }}"
          if [[ "$SAFE_TAG" == *SNAPSHOT* ]]; then
            # For snapshot builds, use a tag that won't cause issues with version parsing
            echo "Using safe tag format for snapshot build"
            sed -i "s/tag: v1.0.0/tag: v0.0.0-snapshot/g" contrib/flatpak/io.github.jmylchreest.keylightd.yml
          else
            # For regular releases, use the actual tag
            sed -i "s/tag: v1.0.0/tag: $SAFE_TAG/g" contrib/flatpak/io.github.jmylchreest.keylightd.yml
          fi

          # Display the updated manifest for debugging
          echo "=== Updated Flatpak Manifest ==="
          grep -A 5 "tag:" contrib/flatpak/io.github.jmylchreest.keylightd.yml

      - uses: flatpak/flatpak-github-actions/flatpak-builder@v6
        with:
          bundle: keylightd-${{ inputs.version }}-${{ matrix.arch }}.flatpak
          manifest-path: contrib/flatpak/io.github.jmylchreest.keylightd.yml
          cache-key: flatpak-builder-${{ github.sha }}-${{ matrix.arch }}
          arch: ${{ matrix.arch }}

      - name: Upload to Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ inputs.tag_name }}
          files: keylightd-${{ inputs.version }}-${{ matrix.arch }}.flatpak
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
